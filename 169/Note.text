自己的思路
将数组排序，找出中间的那个数，除中间外，左边的和右边的出现的次数相同，中间的就是多出现的一个数

时间复杂度分析
内置函数排序，用的是快速排序或者归并排序，那么时间复杂度就为O(nlogn)

空间复杂度分析
如果数组元素不多的话就用快速排序，空间复杂度就为:O(1)
如果数组元度多的话就用归并排序，空间复杂度就为:O(n)


别人的思路1
暴力算法，算出没个元素出现的总次数，如果有元素出现次数超过一半，那么就是这个数

时间复杂度分析
遍历两次，一次是找出一个数的时间为T(n)
第二次再遍历数组，记录出现的次数，所用时间为T(n)
用的总时间就为T(n)=T(n)+T(n)
转成高阶无穷小就为:O(n)

空间复杂度分析
没有用到额外的数组，所以空间复杂度就为:O(1)


别人的思路2
遍历一遍数组，如果出现和没出现的次数相同，那么最后剩下的一个肯定就是多出来的一个数

时间复杂度分析
就遍历了一次数组，所以时间复杂度为:O(n)

空间复杂分析
没有用到额外的空间，所以空间复杂度就为:O(1)
