一开始的思路就是将数字转换成字符串，然后再将字符串转数组遍历，遇到1就count++，一直到结束
初始代码：
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int count = 0;
        String s= Integer.toBinaryString(n);
        for(char c : s.toCharArray()){
            if(c=='1'){
                count++;
            }
        }
        return count;
  }
}

下面分析一下时空复杂度，对时间来说，遍历了一整个数组，所以时间的复杂度肯定就是O(n)，空间的话并没有用到额外的空间，那么空间的复杂度就是O(1)
时空的复杂度还是没有达到最优，那么应该找一个最优化的算法来做。


优化之后可以选择用二进制的运算来解决这个问题。思路就是，将整数中的1减一个算一个，直到整数彻底为0结束。
n&(n-1)就是用来这么做的，可以举个例子就是n=1011，那么n-1=1010，取与之后可以看到得出来的结果就是1010相比于n来说已经少了一个1了，那么count++
接下来继续n=1010了，n-1=1001，取与之后得到1000，又少了一个1，那么count++
最后n=1000，n-1=0111，取与之后的结果就为0000，count++
n=0了那么循环结束

这个算法的时间复杂度完全取决于n中1的个数，以32位的2进制为例，那么这个最坏的情况时间复杂度就是T（32），那么也就是O（1）
空度复杂度同样没有借助其他的空间，那么空间复杂度也为O（1）
