一开始自己的想法是创建二进制字符串，根据index向后扫描对比，不一致的count+1
 时间复杂度分析，用for循环索引k次，k为二进制的bit数，那么时间就为T(k)，假设32位，那么转高阶无穷小就是O(1)
 空间复杂度分析，每次循环都需要一个临时的空间储存字符串相应索引的char值，那么空间复杂度就为O(n)
 
 别人的思路1
 首先将x^y 取异或，作用就是找出两个二进制数中不同的地方
 接着开始与1比较，如果不同异或得到的值就为1，那么count+1
 在把异或的值右移直到0
 时间复杂度分析
 与前面的一样，最坏的情况就是把二进制第一位是1，那么一直要移动k位，时间就为T(k).最好的情况就是只有最后一位为1，那么只用一次,时间就为T(1_
 平均来看，时间复杂度就为:O(1)
 空间复杂度分析
 并没有用到额外的空间，那么空间复杂度就为:O(1)
 
 别人的思路2
 首先将x和y分别右移，然后分别比较x，y的最后一位，是否相同，不同count+1
 时间复杂度分析
 不论最好还是最差，都会一直移动到结束，所以时间就为T(k),最后时间复杂度就为:O(1)
 空间复杂度分析
 没有用到额外的空间，所以空间复杂度为:O(1)
 
 别人的思路3
 将x和y取异或，数里面有几个1就行
 时间复杂度分析
 异或用时为1，数几个1内置函数用的就是右移取与，所以时间为T(k),最后时间复杂度为:O(1)
 空间复杂度分析
 没有用到额外的空间，所以空间复杂度为:O(1)
 
