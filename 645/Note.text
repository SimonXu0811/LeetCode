自己的思路
首先创建一个比原数组长度多一的数组temp，如果缺失的最后一位，这样索引能对应上
然后将nums中的数做为索引，在temp中记录该索引出现的次数
最后遍历，temp中数值为0的就是缺失的，数值为2的就是重复的

时间复杂度分析
第一次把nums放进temp所用的时间为T(n)
第二次遍历temp的时间为T(n+1)
这样总时间就为T(n+1)+T(n)
转成高阶无穷小就是:O(n)

空间复杂度分析
借用了两次temp中的n+1的空间，所以总临时空间为T(2n)
这样转成高阶无穷小空间复杂度就为:O(n)



别人的思路1
创建hashMap，把数值和索引都对应的放进哈希表中，如果存在数值就加一

时间复杂度分析
遍历一遍数组时间为T(n)，然后放入对应的哈希表中要查找并且放入所以是T(n)
然后再查找时间为T(n)
所以总时间为T(n)=T(n^2)+T(n)
转成高阶无穷小就为O(n^2)

空间复杂度分析
每一次插入都借助了一个临时的储存空间，所以空间复杂度就为O(n)



别人的思路2
先遍历数组，将数值和数组对应归位，把多余的那个放到缺失的数值索引上
然后再遍历，有不对应的那就是两个答案

时间复杂度分析
遍历数组用时T(n)
然后再遍历找答案T(n)
总时间就为T(n)=T(n)+T(n)
转成高阶无穷小就是O(n)

空间复杂度分析
每次交换顺序都会创建一个临时的数据，所以空间复杂度就为O(n)



别人的思路3
先遍历数组，把该数组对应的索引乘-1，如果发现该数已经为负，那么就是重复出现的，break
再遍历一遍数组，如果有索引上的数还是正，那么就是没出现的

时间复杂度分析
两次遍历并且都不嵌套，所以总用时为T(n)=T(n)+T(n),转成高阶无穷小就为O(n)

空间复杂度分析
没有用到额外的空间，所以空间复杂度为O(1)

