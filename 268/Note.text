自己的方法，根据异或的性质，相同的数异或为0，0与任何数异或为数本身
那么将0～n，以及nums[0]~nums[nums.length-1]，以及nums.length全部异或
最后剩下的数就为缺失的数

时间复杂度分析
要将数组全部遍历，所以时间的复杂度为:O(n)

空间复杂度分析
没有用到额外的数组，所以空间复杂度为:O(1)



别人的思路1
用哈希表，把数存在哈希表中，如果不存在那么就是缺失的数

时间复杂度分析
将数存到哈希表中用时为nT(1)
遍历0~n判断是否存在用时T(n)
总用时为T(n)=nT(1)+T(n)
转成高阶无穷小就为:O(n)

空间复杂度分析
每插入一个数就用了一个临时空间，所以总用的空间为T(n+1)
转成高阶无穷小为:O(n)



别人的思路2
利用数学的方法，先将0～n全部加起来，然后再将数组元素全部加起来
然后做差，差值就是缺失的数

时间复杂度分析
第一个循环0～n向加，所以用时为T(n+1)
第二个循环遍历数组，所以用时为T(n)
总用时为T(n)=T(n+1)+T(n)
转成高阶无穷小就为:O(n)

空间复杂度分析
没有用到额外的空间，所以空间复杂度就为:O(1)



别人的思路3
先排序，判断头尾是否一致，在判断中间是否一致，不一致的就返回索引

时间复杂度分析
内置排序所用时间为T(nlogn)
遍历数组用时为T(n)
总用时间为T(n)=T(nlogn)+T(n)
转成高阶无穷小为:O(nlogn)

空间复杂度分析
没有用到额外的空间，所以空间复杂度为:O(1)
