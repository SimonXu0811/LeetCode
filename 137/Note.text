自己的思路，创建哈希表，把数组中的数值做为hash的索引，然后储存出现的次数

时间复杂度分析
首先遍历数组，时间花费T(n),然后插入哈希表中T(1)
再遍历一次数组，找出只出现一次的数据，时间花费T(n)
总时间就为T(n)=T(n)+T(n)
转成高阶无穷小就为:O(n)

空间复杂度分析
每次存储都借助了hash的临时地址，所以空间复杂度为:O(n)



别人的思路，利用香农定理来推算，首先创建两个bit记为a=0和b=0
然后利用公式 b = (b^i) & ~a;
           a = (a^i) & ~b;
           首先要了解 0^i=i，因为与0异或，所有的1都会被保留下来
           那么i^i=0就很好理解了，与本身异或全部相等，就为0
           下面推理这个公式
           第一次出现i时， b = (0^i) & 1 = i
                         a = (0^i) & ~i = 0
           第二次出现i时， b = (i^i) & 1 = 0
                         a = (0^i) & 1 = i
           第三次出现i时， b = (0^i) & ~i = 0
                         a = (i^i) & 0 = 0
           可以看见三次循环之后就归零了，所以就可以利用这个公式，出现1次的最后会被保存在b中

时间复杂度分析
就经过了一次遍历，所以时间复杂度就为:O(n)
空间复杂度分析
没有用到临时的空间，所以空间复杂度为:O(1)
