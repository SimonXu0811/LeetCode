自己的思路
暴力算法，第一次遍历数组，将数组的值假设为一个答案
然后再遍历一次数组，先计算出另一个目标值，然后再数组中找是否有答案

时间复杂度分析
第一次遍历数组所用时间为T(n)
第二次遍历数组所用时间为T(n-i)
由于两个嵌套，所用的总时间为T(n)=T(n)*T(n-i)
转成高阶无穷小为:O(n^2)

空间复杂度分析
没有用到额外的储存空间，所以空间复杂度为:O(1)



别人的思路
用哈希表储存数组，先遍历一遍数组，把数组的值做为key，索引做为value
计算出目标值如果在hashmap中存在，那么就返回这个数组，如果没有就继续加

时间复杂度分析
遍历了一次数组，所用的时间为T(n)
在哈希表中查询数组的所用时间为T(1)
所以总用时间为T(n)=T(n)*T(1)
转成高阶无穷小为:O(n)

空间复杂度分析
每一次都要将数组保存在hashmap中，所以保存一个数据就会占用一个临时空间
所以空间复杂度
