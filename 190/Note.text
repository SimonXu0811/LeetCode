这道题的思路类比与十进制的颠倒，十进制不转字符串颠倒的方式是，bit = n mode 10，然后res+=10^n * bit
那么二进制的思路也是类似的，先将二进制数从右向左一位一位的取出来，如果取出来是1，那么将res向左移再加一，如果是0那么直接向左移就可以了

这个算法的时空复杂度也取决于二进制的位数，以32位为例，那么时间复杂度为T（32），也就是O（1）的常数时间
空间的话依旧没有用到额外的空间，那么空间复杂度也就为O（1）
