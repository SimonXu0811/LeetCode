自己的思路
首先遍历数组，开始顺时针旋转一次
然后递归，直到旋转的次数为0

时间复杂度分析
遍历一次数组所用的时间为T(n)
递归的次数就为T(k)
所用的总时间就是T(kn)
转成高阶无穷小最坏的情况就是O(n^2)
最好的情况就是O(1)

空间复杂度分析
没有用到额外的数组，所以空间复杂度就为:O(1)



别人的思路
先计算出转移后数组的正确索引，公式就是(index+k)%nums.length，转移的长度超过数组的话，那就取模
然后交换数组，用一个临时的空间储存元素，交换
记录一个起始位置，如果最后的转换位置等于了起始位置，那么就结束

时间复杂度分析
就遍历了一次数组查找，其他的都是时间为1的交换位置
所以时间复杂度为:O(n)

空间复杂度分析
用到的额外空间就是交换时所用的1个空间，使用了k次
所以空间复杂度就为T(k)
转成高阶无穷小就为O(1)
