自己的思路
如果能被三整除，那么就除3循环，一直到不能被3整除为止
然后最后看剩下的数和1比较

自己的代码
class Solution {
    public boolean isPowerOfThree(int n) {
        while(n % 3 == 0 && n != 0){//如果可以被三整除就除3，不行就返回余数
            n /= 3;
        }
        
        return n == 1;//如果是1就是整除的
    }
}

时间复杂度分析
一直除三循环，所以时间复杂度为:O(logn)

空间复杂度分析
原地算法，所以空间复杂度为:O(1)



别人的思路
直接用3^19 % n看是否可以整除，因为3^20会超过int的最大值，所以不用考虑

别人的代码
class Solution {
    public boolean isPowerOfThree(int n) {
        return (n > 0 && 1162261467 % n == 0);//不能为0，3的次方能被整除的只有3的次方
    }
}

时间复杂度分析
就比较了一次，所以时间复杂度为:O(1)

空间复杂度分析
原地算法，所以空间复杂度为:O(1)
