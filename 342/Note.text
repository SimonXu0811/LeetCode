个人的思路就是用while循环，判断是否能与4整除，如果可以就n/=4，如果不行那就可以直接false，循环的条件就是能整除4
比如256就是 256%4==0成立，那么就256/4=64； 第二步继续判断64%4==0成立，64/4=16； 第三步16%4==0成立，16/4=4； 4%4==0成立，4/4=1，最后返回1==1
由于一步一步循环，那么这种算法的时间复杂度为T（n/4）也就是O（n），没有借助的额外的空间，那么空间复杂度就为O（1）



后面一种算法就是利用位运算，思路就是每次将1的二进制数左移两位（因为以4为幂）如果与n异或是0，那么一定是以4为幂的数。
以64为例，64=1000000，先将1左移两位0000100，异或是10000100不满足
                    再将1左移两位0010000，异或是1010000不满足
                    再将1左移两位1000000，异或是0000000满足，则返回true
                    
这个算法的时间复杂度是T（15）因为循环了15次，那么转成高阶就是O（1）
空间并没有借助额外的空间， 那么空间的复杂度就为O（
